{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Docker Docs Documentation for my Docker \ud83d\udc0b images. Registries Architectures My images support the following three architectures: armv7 arm64 amd64 License Apache 2.0 License Author This project was started in 2021 by Nicholas Wilde .","title":"Home"},{"location":"#docker-docs","text":"Documentation for my Docker \ud83d\udc0b images.","title":"Docker Docs"},{"location":"#registries","text":"","title":"Registries"},{"location":"#architectures","text":"My images support the following three architectures: armv7 arm64 amd64","title":"Architectures"},{"location":"#license","text":"Apache 2.0 License","title":"License"},{"location":"#author","text":"This project was started in 2021 by Nicholas Wilde .","title":"Author"},{"location":"development/","text":"Development Setup My docker images are typically linux multi-architecture (armv7, arm64, & amd64) because I run a RPi cluster. I use buildx to build my multi-architecture images. Check that you can build the following: docker buildx ls NAME/NODE DRIVER/ENDPOINT STATUS PLATFORMS mybuilder * docker-container mybuilder0 unix:///var/run/docker.sock running linux/amd64, linux/arm64, linux/arm/v7 If you are having trouble building arm images on a x86 machine, see this blog post . Also checkout qemu-user-static . docker run --rm --privileged multiarch/qemu-user-static:register --reset Task The docker repos use task to automate the development processes. TL;DR Create Image # Create a new repo from the template repo. https://github.com/nicholaswilde/docker-template/generate # Manually add app version to the VERSION file. Make sure a new line character does not exist at the end of the file. printf <version number> > VERSION # Update task.env with all appropriate values. ... hack, hack, hack ... # Get the checksum of the release or source package. task chk:print # Export the checksum of the release or source package to the CHECKSUM file. task chk:export # Create the Dockerfile ... hack, hack, hack ... # Build the image task build # Load the image task load # Run the image task run # Update goss.yaml ... hack, hack, hack ... # Test the image with GOSS task goss:run Update Image # Print the latest app version and confirm that the correct version is pulled. task version:print # Export the version to the VERSION file task version:export # Get the checksum of the release or source package. task chk:print # Export the checksum of the release or source package to the CHECKSUM file. task chk:export # Increment the LS value task ls:increment # Update the Dockerfile ... hack, hack, hack ... # Build the image task build # Load the image task load # Run the image task run # Test the image with GOSS task goss:run Directory Layout docker-appname \u251c\u2500\u2500 .github/workflows \u2502 \u2514\u2500\u2500 ci.yaml \u251c\u2500\u2500 CHECKSUM \u251c\u2500\u2500 docker-compose.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 goss.yaml \u251c\u2500\u2500 LS \u251c\u2500\u2500 task.env \u2514\u2500\u2500 VERSION Files The CHECKSUM , LS , and VERSION files are all used to pass variables to the ci.yaml Github Action. Note For the commands below, printf should be used rather than echo so that a newline character is not added to the end of the files. This needs to be done so in order for the ci.yaml github action can read the values into variables correctly. CHECKSUM Used to pass in the sha256 checksum of the downloaded file. # Manual printf \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" > CHECKSUM # Task task chk:export Dockerfile The Dockerfile, of course! goss.yaml The Goss config file used by the ci.yaml Github Action. LS Used to pass in the image version. Note My Docker images are based off of LinuxServer.io's . LS, I believe stands for LinuxServer. # Manual printf \"2\" > LS # Task task ls:increment task.env Used to pass other variables into Task. VERSION Used to pass in the app version. # Manual printf \"0.1.0\" > VERSION # Task task version:export Troubleshooting See Troubleshooting","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#setup","text":"My docker images are typically linux multi-architecture (armv7, arm64, & amd64) because I run a RPi cluster. I use buildx to build my multi-architecture images. Check that you can build the following: docker buildx ls NAME/NODE DRIVER/ENDPOINT STATUS PLATFORMS mybuilder * docker-container mybuilder0 unix:///var/run/docker.sock running linux/amd64, linux/arm64, linux/arm/v7 If you are having trouble building arm images on a x86 machine, see this blog post . Also checkout qemu-user-static . docker run --rm --privileged multiarch/qemu-user-static:register --reset","title":"Setup"},{"location":"development/#task","text":"The docker repos use task to automate the development processes.","title":"Task"},{"location":"development/#tldr","text":"","title":"TL;DR"},{"location":"development/#create-image","text":"# Create a new repo from the template repo. https://github.com/nicholaswilde/docker-template/generate # Manually add app version to the VERSION file. Make sure a new line character does not exist at the end of the file. printf <version number> > VERSION # Update task.env with all appropriate values. ... hack, hack, hack ... # Get the checksum of the release or source package. task chk:print # Export the checksum of the release or source package to the CHECKSUM file. task chk:export # Create the Dockerfile ... hack, hack, hack ... # Build the image task build # Load the image task load # Run the image task run # Update goss.yaml ... hack, hack, hack ... # Test the image with GOSS task goss:run","title":"Create Image"},{"location":"development/#update-image","text":"# Print the latest app version and confirm that the correct version is pulled. task version:print # Export the version to the VERSION file task version:export # Get the checksum of the release or source package. task chk:print # Export the checksum of the release or source package to the CHECKSUM file. task chk:export # Increment the LS value task ls:increment # Update the Dockerfile ... hack, hack, hack ... # Build the image task build # Load the image task load # Run the image task run # Test the image with GOSS task goss:run","title":"Update Image"},{"location":"development/#directory-layout","text":"docker-appname \u251c\u2500\u2500 .github/workflows \u2502 \u2514\u2500\u2500 ci.yaml \u251c\u2500\u2500 CHECKSUM \u251c\u2500\u2500 docker-compose.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 goss.yaml \u251c\u2500\u2500 LS \u251c\u2500\u2500 task.env \u2514\u2500\u2500 VERSION","title":"Directory Layout"},{"location":"development/#files","text":"The CHECKSUM , LS , and VERSION files are all used to pass variables to the ci.yaml Github Action. Note For the commands below, printf should be used rather than echo so that a newline character is not added to the end of the files. This needs to be done so in order for the ci.yaml github action can read the values into variables correctly.","title":"Files"},{"location":"development/#checksum","text":"Used to pass in the sha256 checksum of the downloaded file. # Manual printf \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" > CHECKSUM # Task task chk:export","title":"CHECKSUM"},{"location":"development/#dockerfile","text":"The Dockerfile, of course!","title":"Dockerfile"},{"location":"development/#gossyaml","text":"The Goss config file used by the ci.yaml Github Action.","title":"goss.yaml"},{"location":"development/#ls","text":"Used to pass in the image version. Note My Docker images are based off of LinuxServer.io's . LS, I believe stands for LinuxServer. # Manual printf \"2\" > LS # Task task ls:increment","title":"LS"},{"location":"development/#taskenv","text":"Used to pass other variables into Task.","title":"task.env"},{"location":"development/#version","text":"Used to pass in the app version. # Manual printf \"0.1.0\" > VERSION # Task task version:export","title":"VERSION"},{"location":"development/#troubleshooting","text":"See Troubleshooting","title":"Troubleshooting"},{"location":"faq/","text":"FAQ What does LS stand for at the end of the image tag? My images are based off of LinuxServer.io's images and they use an ls at the end of their images to denote changes only to th image and not the app. My images increment the LS value even if just the app changes.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what-does-ls-stand-for-at-the-end-of-the-image-tag","text":"My images are based off of LinuxServer.io's images and they use an ls at the end of their images to denote changes only to th image and not the app. My images increment the LS value even if just the app changes.","title":"What does LS stand for at the end of the image tag?"},{"location":"goss/","text":"Goss Goss is used by ci.yaml Github Action to validate that the Docker image is working. Note The goss test will be skipped if the goss.yaml file is not present. TL;DR # Edit the goss.yaml file ... hack, hack, hack ... # Test the goss file. task goss:run Installation # Install latest version to /usr/local/bin curl -fsSL https://goss.rocks/install | sh # Install dgoss curl -L https://raw.githubusercontent.com/aelsabbahy/goss/master/extras/dgoss/dgoss -o /usr/local/bin/dgoss chmod +rx /usr/local/bin/dgoss","title":"Goss"},{"location":"goss/#goss","text":"Goss is used by ci.yaml Github Action to validate that the Docker image is working. Note The goss test will be skipped if the goss.yaml file is not present.","title":"Goss"},{"location":"goss/#tldr","text":"# Edit the goss.yaml file ... hack, hack, hack ... # Test the goss file. task goss:run","title":"TL;DR"},{"location":"goss/#installation","text":"# Install latest version to /usr/local/bin curl -fsSL https://goss.rocks/install | sh # Install dgoss curl -L https://raw.githubusercontent.com/aelsabbahy/goss/master/extras/dgoss/dgoss -o /usr/local/bin/dgoss chmod +rx /usr/local/bin/dgoss","title":"Installation"},{"location":"linting/","text":"Linting My Docker repositories use yamllint and hadolint to lint the repositories. # Use the Makefile to lint the repository. make lint Yamllint # Manually lint yamllint . Hadolint # Manually lint hadolint Dockerfile Pin Package Versions ( DL3008 ) Copy the packages list and name of the base image from the Dockerfile to variables PACKAGES and BASE respectively in make.env/task.env . Run make packages/task packages to list the package versions. task packages-alpine ... ca-certificates policy: 20191127 -r5: lib/apk/db/installed http://dl-cdn.alpinelinux.org/alpine/v3.13/main ... 3. Copy the package versions from stdout over to the Dockerfile . Similar steps may be taken to pin pip ( DL3013 ) and npm ( DL3016 ) packages. Alternatively, a shell may be launched of the build image and manually run apk policy <package> or apt-update && apt-cache policy <package> to get the package versions. Pre-commit hook If you want to automatically generate README.md files with a pre-commit hook, make sure you install the pre-commit binary , and add a .pre-commit-config.yaml to your project. Then run: pre-commit install pre-commit install-hooks Currently, this only works on amd64 systems. Github Action The lint github action is also used to lint the repo upon commit.","title":"Linting"},{"location":"linting/#linting","text":"My Docker repositories use yamllint and hadolint to lint the repositories. # Use the Makefile to lint the repository. make lint","title":"Linting"},{"location":"linting/#yamllint","text":"# Manually lint yamllint .","title":"Yamllint"},{"location":"linting/#hadolint","text":"# Manually lint hadolint Dockerfile","title":"Hadolint"},{"location":"linting/#pin-package-versions-dl3008","text":"Copy the packages list and name of the base image from the Dockerfile to variables PACKAGES and BASE respectively in make.env/task.env . Run make packages/task packages to list the package versions. task packages-alpine ... ca-certificates policy: 20191127 -r5: lib/apk/db/installed http://dl-cdn.alpinelinux.org/alpine/v3.13/main ... 3. Copy the package versions from stdout over to the Dockerfile . Similar steps may be taken to pin pip ( DL3013 ) and npm ( DL3016 ) packages. Alternatively, a shell may be launched of the build image and manually run apk policy <package> or apt-update && apt-cache policy <package> to get the package versions.","title":"Pin Package Versions (DL3008)"},{"location":"linting/#pre-commit-hook","text":"If you want to automatically generate README.md files with a pre-commit hook, make sure you install the pre-commit binary , and add a .pre-commit-config.yaml to your project. Then run: pre-commit install pre-commit install-hooks Currently, this only works on amd64 systems.","title":"Pre-commit hook"},{"location":"linting/#github-action","text":"The lint github action is also used to lint the repo upon commit.","title":"Github Action"},{"location":"publishing/","text":"Publishing Setup Browse to .github/workflows/ci.yaml file. Take note of the required github secrets. E.g. DOCKERHUB_TOKEN . Add the repo secrets . Quay.io For the Quay.io registry, you'll need to manually create an image repository. It does not create one upon first push like Docker Hub. Create a quay.io image repository . Give write access to a robot for the newly created image repository. Publishing Publishing images is done through the ci github action . The action is automatically triggered grabs the build variables from the VERSION , CHECKSUM , and LS variables. The github action also creates a release. The name of the image is taken from the repository name after docker- . So, repo docker-etherpad would have an image name of etherpad . Both the current version tag and the latest tag are released. Github Repository Browse to the Actions tab . Click on the ci workflow. Manually trigger the workflow using the app version and image (ls) version. Github Packages By default, a ghcr.io package is published as private and so after the initial release to the ghcr.io registry, the package will need to be converted to a public package if you want anyone to use it. See Configuring visibility of container images for your personal account . You may also set connect your repository to your container image/package. See Connecting a repository to a container image . Troubleshooting See Troubleshooting","title":"Publishing"},{"location":"publishing/#publishing","text":"","title":"Publishing"},{"location":"publishing/#setup","text":"Browse to .github/workflows/ci.yaml file. Take note of the required github secrets. E.g. DOCKERHUB_TOKEN . Add the repo secrets .","title":"Setup"},{"location":"publishing/#quayio","text":"For the Quay.io registry, you'll need to manually create an image repository. It does not create one upon first push like Docker Hub. Create a quay.io image repository . Give write access to a robot for the newly created image repository.","title":"Quay.io"},{"location":"publishing/#publishing_1","text":"Publishing images is done through the ci github action . The action is automatically triggered grabs the build variables from the VERSION , CHECKSUM , and LS variables. The github action also creates a release. The name of the image is taken from the repository name after docker- . So, repo docker-etherpad would have an image name of etherpad . Both the current version tag and the latest tag are released.","title":"Publishing"},{"location":"publishing/#github-repository","text":"Browse to the Actions tab . Click on the ci workflow. Manually trigger the workflow using the app version and image (ls) version.","title":"Github Repository"},{"location":"publishing/#github-packages","text":"By default, a ghcr.io package is published as private and so after the initial release to the ghcr.io registry, the package will need to be converted to a public package if you want anyone to use it. See Configuring visibility of container images for your personal account . You may also set connect your repository to your container image/package. See Connecting a repository to a container image .","title":"Github Packages"},{"location":"publishing/#troubleshooting","text":"See Troubleshooting","title":"Troubleshooting"},{"location":"task/","text":"Task The docker repos use task to automate the development processes. Installation # For Default Installion to ./bin with debug logging sh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d # For Installation To /usr/local/bin for userwide access with debug logging # May require sudo sh sh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin Help task task: Available tasks for this project: * build: Build the native Docker image ...","title":"Task"},{"location":"task/#task","text":"The docker repos use task to automate the development processes.","title":"Task"},{"location":"task/#installation","text":"# For Default Installion to ./bin with debug logging sh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d # For Installation To /usr/local/bin for userwide access with debug logging # May require sudo sh sh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin","title":"Installation"},{"location":"task/#help","text":"task task: Available tasks for this project: * build: Build the native Docker image ...","title":"Help"},{"location":"troubleshooting/","text":"Troubleshooting Development Restart buildkit Often times when coming back to a docker build, the buildkit container needs to be restarted for some reason. ------ > [ base 4 /4 ] RUN echo \"**** install packages ****\" && apk add --no-cache wget = 1 .21.1-r1 gzip = 1 .10-r1: #9 0.139 container_linux.go:367: starting container process caused: process_linux.go:340: applying cgroup configuration for process caused: mkdir /sys/fs/cgroup/blkio/buildkit: no such file or directory ------ To fix this, run the following command to get the container name and then manually restart the container. docker ps CONTAINER ID IMAGE ... NAMES 75316abfd2e3 moby/buildkit:buildx-stable-1 ... buildx_buildkit_mybuilder0 docker restart buildx_buildkit_mybuilder0 Alpine Packages Hadolint recommends that the package version be pinned ( DL3018 ). However, Alpine repositories don't keep older version of packages and so building older versions of Docker images may give errors. To solve these errors, the package versions need to be updated. There are multiple ways to get the package version. Use the online database to lookup the package version. Use the error output to get the latest version of the package. #42 0.206 **** install packages **** #42 0.210 fetch http://dl-cdn.alpinelinux.org/alpine/v3.12/main/x86_64/APKINDEX.tar.gz #42 0.332 fetch http://dl-cdn.alpinelinux.org/alpine/v3.12/community/x86_64/APKINDEX.tar.gz #42 0.442 ERROR: unsatisfiable constraints: #42 0.458 mysql-client-10.4.17-r1: #42 0.458 breaks: world[mysql-client=10.4.15-r0] In the above example, the mysql-client package version needs to be set to 10.4.17-r1 . Launch a shell of the Alpine base image and get the policy of the package you're trying to install. docker run --rm -it alpine:3.13.1 /bin/ash apk policy <package name> Alternatively, you can get the package version directly. docker run --rm -it alpine:3.13.1 /bin/ash -c \"apk update && apk policy <package name>\" ... <package name> policy: 1 .21.1-r1: ... Make sure alpine:3.13.1 is replaced with the base image version that you're using and that <package name> is replaced with the name of the package you're trying to install. Publishing If you receive an unauthorized error when trying to publish the image using the ci github action, it's most likely because you either have invalid credentials, or with respect to quay.io, the repository hasn't been created or the robot account hasn't been given write access. See Publishing#Quay.io . Unauthorized 401","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#development","text":"","title":"Development"},{"location":"troubleshooting/#restart-buildkit","text":"Often times when coming back to a docker build, the buildkit container needs to be restarted for some reason. ------ > [ base 4 /4 ] RUN echo \"**** install packages ****\" && apk add --no-cache wget = 1 .21.1-r1 gzip = 1 .10-r1: #9 0.139 container_linux.go:367: starting container process caused: process_linux.go:340: applying cgroup configuration for process caused: mkdir /sys/fs/cgroup/blkio/buildkit: no such file or directory ------ To fix this, run the following command to get the container name and then manually restart the container. docker ps CONTAINER ID IMAGE ... NAMES 75316abfd2e3 moby/buildkit:buildx-stable-1 ... buildx_buildkit_mybuilder0 docker restart buildx_buildkit_mybuilder0","title":"Restart buildkit"},{"location":"troubleshooting/#alpine-packages","text":"Hadolint recommends that the package version be pinned ( DL3018 ). However, Alpine repositories don't keep older version of packages and so building older versions of Docker images may give errors. To solve these errors, the package versions need to be updated. There are multiple ways to get the package version. Use the online database to lookup the package version. Use the error output to get the latest version of the package. #42 0.206 **** install packages **** #42 0.210 fetch http://dl-cdn.alpinelinux.org/alpine/v3.12/main/x86_64/APKINDEX.tar.gz #42 0.332 fetch http://dl-cdn.alpinelinux.org/alpine/v3.12/community/x86_64/APKINDEX.tar.gz #42 0.442 ERROR: unsatisfiable constraints: #42 0.458 mysql-client-10.4.17-r1: #42 0.458 breaks: world[mysql-client=10.4.15-r0] In the above example, the mysql-client package version needs to be set to 10.4.17-r1 . Launch a shell of the Alpine base image and get the policy of the package you're trying to install. docker run --rm -it alpine:3.13.1 /bin/ash apk policy <package name> Alternatively, you can get the package version directly. docker run --rm -it alpine:3.13.1 /bin/ash -c \"apk update && apk policy <package name>\" ... <package name> policy: 1 .21.1-r1: ... Make sure alpine:3.13.1 is replaced with the base image version that you're using and that <package name> is replaced with the name of the package you're trying to install.","title":"Alpine Packages"},{"location":"troubleshooting/#publishing","text":"If you receive an unauthorized error when trying to publish the image using the ci github action, it's most likely because you either have invalid credentials, or with respect to quay.io, the repository hasn't been created or the robot account hasn't been given write access. See Publishing#Quay.io . Unauthorized 401","title":"Publishing"}]}